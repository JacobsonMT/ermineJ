<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<title>Using the ermineJ API</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>
<h1>Using the ermineJ Application Programming Interface</H1>
<p>ErmineJ consists of two jar files: ermineJ.jar and baseCode.jar. The
latter contains code that is common to other projects, while ermineJ
contains classes that are specific to the gene set scoring task. ErmineJ
has dependencies on a number of other third party libraries including
Commons Configuration. Use of the ermineJ API is covered by the Lesser
Gnu Public License.</p>

<p>While the internal use of the ermineJ API is fairly complex, most of
that complexity is not needed for use by third parties. The minimal
requirements for an analysis are:</p>

<ul>
	<li>A java.util.List of probe ids. This should contain all the probes
	on the microarray design (or at least, not just the ones that met some
	selection criterion)</li>
	<li>A List of gene symbols (in the same order as the probe ids)</li>
	<li>A List of Collections of GO terms for the gene symbols (keyed by
	the probe ids, in the same order as the probes)</li>
	<li>A List of scores for the probe ids. Typically these are p-values,
	but they can be any value you like, inluding a dummy variable
	indicating cluster membership etc.</li>
</ul>


<p>The use of java.util.Lists was intended to make it very easy for
third parties to create data structures that ermineJ can handle. It is
the programmer's responsibility to make sure the Lists are in the
correct order. While ermineJ will detect some types of problems with the
input data structures, it cannot tell that you put the probe IDs in a
different order than the gene symbols.</p>

<p>Once the above are assembled, the analysis proceeds in three phases:</p>

<ol>
	<li>Create a ClassScoreSimple object with the above lists as arguments
	to the constructor</li>
	<li>Configure settings.</li>
	<li>Run the analysis by calling the 'run' method.</li>
</ol>

<p>The results can then be obtained with a simple method call..</p>

<p>The following code snippets demonstrate how to implement these steps.</p>

<div class="java"><pre>
        List probes = null; // List of identifiers to be analyzed
        List genes = null; // List of genes corresponding to the probes. Indicates the Many-to-one mapping of probes to genes.
        List goAssociations = null; // List of Collections of go terms for the probes.
        List geneScores = null; // List of Doubles 
      
        /* ... code to initialize these data structures goes here ... */

        ClassScoreSimple css = new ClassScoreSimple(probes, genes, goAssociations, geneScores);
        
        // in our raw data, smaller values are better (like pvalues, unlike fold
        // change)
        settings.setBigGeneScoreIsBetter( false ); 
                                            
         // set range of sizes of gene sets to consider.
        settings.setMaxClassSize( 100 ); 
        settings.setMinClassSize( 5 );
        
         // use this pvalue threshold for selecting genes. (before taking logs)
        settings.setGeneScoreThreshold( 0.001 );
        
         // use over-representation analysis.
        settings.setClassScoreMethod( Settings.ORA );
        /* ... etc. Reasonable defaults (?) are set for all parameters if you don't set them. */
 
        css.run(); // might want to run in a separate thread.
 		
 		// You should iterate over your tested gene sets.
        double aPvalue = css.getGeneSetPvalue("GO:0000243");
 
 
</pre></div>



</body>
</html>
